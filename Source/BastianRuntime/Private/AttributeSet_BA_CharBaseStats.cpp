// Generated by Attribute Generator (https://bit.ly/AttributeGenerator). MIT license.
// Part of the series 'Create a game with Unreal Lyra - Developer Bastian - https://youtube.com/@BastianDev'

#include "AttributeSet_BA_CharBaseStats.h"
#include "AbilitySystem/Attributes/LyraAttributeSet.h"
#include "AbilitySystemGlobals.h"
#include "Net/UnrealNetwork.h"
#include "LyraGameplayTags.h"
#include "AbilitySystem/LyraAbilitySystemComponent.h"
#include "Engine/World.h"
#include "GameplayEffectExtension.h"
#include "Messages/LyraVerbMessage.h"
#include "Messages/LyraNotificationMessage.h"
#include "GameFramework\GameplayMessageSubsystem.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(AttributeSet_BA_CharBaseStats)
#pragma region Logging and UGameAttributeSet: MUST ONLY EXISTS ONCE IN YOUR PROJECT. IF YOU GENERATE MULTIPLE ATTRIBUTE SETS, DELETE THIS REGION STARTING WITH THE SECOND SET ATTRIBUTESET
#pragma region Logging
DEFINE_LOG_CATEGORY(GameAttributeSet);
#pragma endregion
#pragma region UGameAttributeSet
void UGameAttributeSet::AttachToASC(ULyraAbilitySystemComponent* AbilitySystemComponent)
{
	if (IsValid(AbilitySystemComponent))
	{
		auto AttributeSet = AbilitySystemComponent->GetSet<UGameAttributeSet>();
		if (!IsValid(AttributeSet))	// only grant if AttributeSet was not found already on ASC
		{
			AbilitySystemComponent->AddAttributeSetSubobject(this);
			AbilitySystemComponent->ForceReplication();
			UE_LOG(GameAttributeSet, Log, TEXT("AttachToASC: Attached '%s' to ASC"), *GetNameSafe(this));
		}
		else
		{
			UE_LOG(GameAttributeSet, Warning, TEXT("AttachToASC: AttributeSet '%s' already granted to ASC - not attached again to ASC"), *GetNameSafe(this));
		}
	}
	else
	{
		UE_LOG(GameAttributeSet, Error, TEXT("AttachToASC: Attaching '%s' to ASC failed, ASC not valid"), *GetNameSafe(this));
	}
}

void UGameAttributeSet::RemoveFromASC(ULyraAbilitySystemComponent* AbilitySystemComponent)
{
	if (IsValid(AbilitySystemComponent))
	{
		AbilitySystemComponent->ForceReplication();
		AbilitySystemComponent->RemoveSpawnedAttribute(this);
		AbilitySystemComponent->ForceReplication();
		UE_LOG(GameAttributeSet, Log, TEXT("Removed '%s' from ASC"), *GetNameSafe(this));
	}
	else
	{
		UE_LOG(GameAttributeSet, Error, TEXT("Removing '%s' from ASC failed, ASC not valid"), *GetNameSafe(this));
	}
}

TArray<FGameplayAttribute> UGameAttributeSet::GetAttributesForAttributeSetClass(ULyraAbilitySystemComponent* AbilitySystemComponent, TSubclassOf<UAttributeSet> AttributSetClass)
{
	TArray<FGameplayAttribute> AttributeArray;
	if (IsValid(AbilitySystemComponent))
	{
		const UAttributeSet* AttributeSet = AbilitySystemComponent->GetAttributeSet(AttributSetClass);
		if (IsValid(AttributeSet))
		{
			TArray<FGameplayAttribute> Attributes;
			AbilitySystemComponent->GetAllAttributes(Attributes);
			FString AttributeNames = "";
			for (FGameplayAttribute Attribute : Attributes)
			{
				UClass* AttributeClass = Attribute.GetAttributeSetClass();
				if (AttributeClass->IsChildOf(AttributSetClass))
				{
					AttributeArray.Add(Attribute);
					AttributeNames.Append(Attribute.AttributeName + ": " + FString::SanitizeFloat(Attribute.GetNumericValue(AttributeSet)) + "\t");
				}
			}
			UE_LOG(GameAttributeSet, Log, TEXT("GetAttributesFromAttributeSet: Returned %d Attribues for AttributeSet class '%s': %s"), AttributeArray.Num(), *GetNameSafe(this), *AttributeNames);
		}
		else
		{
			UE_LOG(GameAttributeSet, Warning, TEXT("GetAttributesFromAttributeSet: No valid AttributeSet of class '' found"), *GetNameSafe(AttributSetClass));
		}
	}
	else
	{
		UE_LOG(GameAttributeSet, Warning, TEXT("GetAttributesFromAttributeSet: ASC not valid"), *GetNameSafe(AbilitySystemComponent));
	}
	return AttributeArray;
}
#pragma endregion
#pragma endregion DELETE UNTIL HERE IF YOU USE MULTIPLE ATTRIBUTE SETS
#pragma region GameplayTags
UE_DEFINE_GAMEPLAY_TAG(TAG_AttributeSet_BA_CharBaseStats_Strength, "AttributeSets.AttributeSet_BA_CharBaseStats.Strength");
FGameplayTag UAttributeSet_BA_CharBaseStats::GetGameplayTag_Strength() const
{
	return FGameplayTag::RequestGameplayTag(FName("AttributeSets.AttributeSet_BA_CharBaseStats.Strength"));
}
UE_DEFINE_GAMEPLAY_TAG(TAG_AttributeSet_BA_CharBaseStats_Endurance, "AttributeSets.AttributeSet_BA_CharBaseStats.Endurance");
FGameplayTag UAttributeSet_BA_CharBaseStats::GetGameplayTag_Endurance() const
{
	return FGameplayTag::RequestGameplayTag(FName("AttributeSets.AttributeSet_BA_CharBaseStats.Endurance"));
}
UE_DEFINE_GAMEPLAY_TAG(TAG_AttributeSet_BA_CharBaseStats_Intelligence, "AttributeSets.AttributeSet_BA_CharBaseStats.Intelligence");
FGameplayTag UAttributeSet_BA_CharBaseStats::GetGameplayTag_Intelligence() const
{
	return FGameplayTag::RequestGameplayTag(FName("AttributeSets.AttributeSet_BA_CharBaseStats.Intelligence"));
}
UE_DEFINE_GAMEPLAY_TAG(TAG_AttributeSet_BA_CharBaseStats_Dexterity, "AttributeSets.AttributeSet_BA_CharBaseStats.Dexterity");
FGameplayTag UAttributeSet_BA_CharBaseStats::GetGameplayTag_Dexterity() const
{
	return FGameplayTag::RequestGameplayTag(FName("AttributeSets.AttributeSet_BA_CharBaseStats.Dexterity"));
}

#pragma endregion

class FLifetimeProperty;

UAttributeSet_BA_CharBaseStats::UAttributeSet_BA_CharBaseStats()
	: Strength(0.0f), Endurance(0.0f), Intelligence(0.0f), Dexterity(0.0f)
{
}

#pragma region Replication
void UAttributeSet_BA_CharBaseStats::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME_CONDITION_NOTIFY(UAttributeSet_BA_CharBaseStats, Strength, COND_OwnerOnly, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UAttributeSet_BA_CharBaseStats, Endurance, COND_OwnerOnly, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UAttributeSet_BA_CharBaseStats, Intelligence, COND_OwnerOnly, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UAttributeSet_BA_CharBaseStats, Dexterity, COND_OwnerOnly, REPNOTIFY_Always);

}

void UAttributeSet_BA_CharBaseStats::OnRep_Strength(const FGameplayAttributeData& OldValue)
{
	static FProperty* Prop = FindFieldChecked<FProperty>(UAttributeSet_BA_CharBaseStats::StaticClass(), GET_MEMBER_NAME_CHECKED(UAttributeSet_BA_CharBaseStats, Strength));
	ULyraAbilitySystemComponent* ASC = CastChecked<ULyraAbilitySystemComponent>(GetOuter(), ECastCheckedType::NullAllowed);
	if (IsValid(ASC))
	{
		ASC->SetBaseAttributeValueFromReplication(FGameplayAttribute(Prop), Strength, OldValue);
	}
	else
	{
		UE_LOG(GameAttributeSet, Error, TEXT("UAttributeSet_BA_CharBaseStatss::OnRep_Strength: No valid ASC found"));
	}
}

void UAttributeSet_BA_CharBaseStats::OnRep_Endurance(const FGameplayAttributeData& OldValue)
{
	static FProperty* Prop = FindFieldChecked<FProperty>(UAttributeSet_BA_CharBaseStats::StaticClass(), GET_MEMBER_NAME_CHECKED(UAttributeSet_BA_CharBaseStats, Endurance));
	ULyraAbilitySystemComponent* ASC = CastChecked<ULyraAbilitySystemComponent>(GetOuter(), ECastCheckedType::NullAllowed);
	if (IsValid(ASC))
	{
		ASC->SetBaseAttributeValueFromReplication(FGameplayAttribute(Prop), Endurance, OldValue);
	}
	else
	{
		UE_LOG(GameAttributeSet, Error, TEXT("UAttributeSet_BA_CharBaseStatss::OnRep_Endurance: No valid ASC found"));
	}
}

void UAttributeSet_BA_CharBaseStats::OnRep_Intelligence(const FGameplayAttributeData& OldValue)
{
	static FProperty* Prop = FindFieldChecked<FProperty>(UAttributeSet_BA_CharBaseStats::StaticClass(), GET_MEMBER_NAME_CHECKED(UAttributeSet_BA_CharBaseStats, Intelligence));
	ULyraAbilitySystemComponent* ASC = CastChecked<ULyraAbilitySystemComponent>(GetOuter(), ECastCheckedType::NullAllowed);
	if (IsValid(ASC))
	{
		ASC->SetBaseAttributeValueFromReplication(FGameplayAttribute(Prop), Intelligence, OldValue);
	}
	else
	{
		UE_LOG(GameAttributeSet, Error, TEXT("UAttributeSet_BA_CharBaseStatss::OnRep_Intelligence: No valid ASC found"));
	}
}

void UAttributeSet_BA_CharBaseStats::OnRep_Dexterity(const FGameplayAttributeData& OldValue)
{
	static FProperty* Prop = FindFieldChecked<FProperty>(UAttributeSet_BA_CharBaseStats::StaticClass(), GET_MEMBER_NAME_CHECKED(UAttributeSet_BA_CharBaseStats, Dexterity));
	ULyraAbilitySystemComponent* ASC = CastChecked<ULyraAbilitySystemComponent>(GetOuter(), ECastCheckedType::NullAllowed);
	if (IsValid(ASC))
	{
		ASC->SetBaseAttributeValueFromReplication(FGameplayAttribute(Prop), Dexterity, OldValue);
	}
	else
	{
		UE_LOG(GameAttributeSet, Error, TEXT("UAttributeSet_BA_CharBaseStatss::OnRep_Dexterity: No valid ASC found"));
	}
}


#pragma endregion

#pragma region PRE-POST Gameplay Effects
void UAttributeSet_BA_CharBaseStats::PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data)
{
	Super::PostGameplayEffectExecute(Data);
	if (Data.EvaluatedData.Magnitude != 0.0f)
	{
		FGameplayTag Tag = FGameplayTag::RequestGameplayTag(FName("AttributeSets.AttributeSet_BA_CharBaseStats." + Data.EvaluatedData.Attribute.AttributeName));
		if (Tag.IsValid())
		{
			FLyraVerbMessage Message;
			Message.Verb = Tag;
			Message.Instigator = Data.EffectSpec.GetEffectContext().GetEffectCauser();
			Message.InstigatorTags = *Data.EffectSpec.CapturedSourceTags.GetAggregatedTags();
			ULyraAbilitySystemComponent* ASC = CastChecked<ULyraAbilitySystemComponent>(GetOuter(), ECastCheckedType::NullAllowed);
			if (IsValid(ASC))
			{
				Message.Target = ASC->GetOwner();
			}
			Message.TargetTags = *Data.EffectSpec.CapturedTargetTags.GetAggregatedTags();
			Message.Magnitude = Data.EvaluatedData.Magnitude;

			UGameplayMessageSubsystem& MessageSystem = UGameplayMessageSubsystem::Get(GetWorld());
			MessageSystem.BroadcastMessage(Tag, Message);
			UE_LOG(GameAttributeSet, Verbose, TEXT("PostGameplayEffectExecute: Broadcasted msg for tag '%s' with insigator '%s' and target '%s'")
				, Tag.GetTagName(), *Message.Instigator->GetName(), *Message.Target->GetName());
		}
		else
		{
			UE_LOG(GameAttributeSet, Error, TEXT("PostGameplayEffectExecute: Broadcast failed, tag '%s' is not valid"), Tag.GetTagName());
		}
	}
	else
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("PostAttributeChange: No message was broadcasted, magnitude = 0"));
	}
}
#pragma endregion

#pragma region PRE-POST Attribute Changes

void UAttributeSet_BA_CharBaseStats::PreAttributeBaseChange(const FGameplayAttribute& Attribute, float& NewValue) const
{
	Super::PreAttributeBaseChange(Attribute, NewValue);
	ClampAttribute(Attribute, NewValue);
}

void UAttributeSet_BA_CharBaseStats::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)
{
	Super::PreAttributeChange(Attribute, NewValue);
	ClampAttribute(Attribute, NewValue);
}

void UAttributeSet_BA_CharBaseStats::PostAttributeChange(const FGameplayAttribute& Attribute, float OldValue, float NewValue)
{
	Super::PostAttributeChange(Attribute, OldValue, NewValue);
	ULyraAbilitySystemComponent* ASC = CastChecked<ULyraAbilitySystemComponent>(GetOuter(), ECastCheckedType::NullAllowed);
	if (IsValid(ASC))
	{
		if (Attribute.GetGameplayAttributeData(this)->GetCurrentValue() > Attribute.GetGameplayAttributeData(this)->GetBaseValue())
		{
			ASC->ApplyModToAttribute(Attribute, EGameplayModOp::Override, NewValue);
		}
		// cast a message with PlayerState and Tag Channel for everyone listening
		if (IsValid(ASC->GetOwner()))
		{
			FGameplayTag Tag = FGameplayTag::RequestGameplayTag(FName("AttributeSets.AttributeSet_BA_CharBaseStats." + Attribute.AttributeName));
			if (Tag.IsValid())
			{
				FLyraNotificationMessage Message;
				Message.TargetChannel = Tag;
				Message.TargetPlayer = (APlayerState*)ASC->GetOwner();
				UGameplayMessageSubsystem& MessageSystem = UGameplayMessageSubsystem::Get(GetWorld());
				MessageSystem.BroadcastMessage(Tag, Message);
				UE_LOG(GameAttributeSet, Verbose, TEXT("PostAttributeChange: Broadcasted msg for tag '%s' - oldvalue: %d, new value: %d")
					, Tag.GetTagName(), OldValue, NewValue);
			}
			else
			{
				UE_LOG(GameAttributeSet, Error, TEXT("PostAttributeChange: Broadcast failed, tag '%s' is not valid"), Tag.GetTagName());
			}
		}
		else
		{
			UE_LOG(GameAttributeSet, Error, TEXT("PostAttributeChange: Getting a valid owner from ASC failed - aborted"));
		}
	}
	else
	{
		UE_LOG(GameAttributeSet, Error, TEXT("PostAttributeChange: Getting a valid ASC failed - aborted"));
	}
}

void UAttributeSet_BA_CharBaseStats::OnAttributeAggregatorCreated(const FGameplayAttribute& Attribute, FAggregator* NewAggregator) const
{
	Super::OnAttributeAggregatorCreated(Attribute, NewAggregator);

	if (!NewAggregator)
	{
		return;
	}
	/*
	// Example from Tranek: Only leave the most negative mod but all positive mods on each attribute (example: movement speed)
	if (Attribute == GetMoveSpeedAttribute())
	{
		NewAggregator->EvaluationMetaData = &FAggregatorEvaluateMetaDataLibrary::MostNegativeMod_AllPositiveMods;
	}
	*/
}

void UAttributeSet_BA_CharBaseStats::ClampAttribute(const FGameplayAttribute& Attribute, float& NewValue) const
{
	// Do not allow the new value to be higher than base value
	auto Data = Attribute.GetGameplayAttributeData(this);
	if (Data->GetBaseValue() < Data->GetCurrentValue())
	{
		NewValue = Data->GetBaseValue();
		UE_LOG(GameAttributeSet, Warning, TEXT("Current value for %s is %d, but base value is smaller at %d. New value clamped at to base value")
			, *Attribute.AttributeName, Data->GetCurrentValue(), Data->GetBaseValue());
	}
}
#pragma endregion