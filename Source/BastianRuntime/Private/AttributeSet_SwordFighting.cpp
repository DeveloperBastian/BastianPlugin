// Generated by Attribute Generator (https://bit.ly/AttributeGenerator). MIT license.
// Part of the series 'Create a game with Unreal Lyra - Developer Bastian - https://youtube.com/@BastianDev'

#include "AttributeSet_SwordFighting.h"
#include "AbilitySystem/Attributes/LyraAttributeSet.h"
#include "AbilitySystemGlobals.h"
#include "Net/UnrealNetwork.h"
#include "LyraGameplayTags.h"
#include "AbilitySystem/LyraAbilitySystemComponent.h"
#include "Engine/World.h"
#include "GameplayEffectExtension.h"
#include "Messages/LyraVerbMessage.h"
#include "Messages/LyraNotificationMessage.h"
#include "GameFramework\GameplayMessageSubsystem.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(AttributeSet_SwordFighting)

#pragma region GameplayTags
UE_DEFINE_GAMEPLAY_TAG(TAG_AttributeSet_SwordFighting_Swiftness, "AttributeSets.AttributeSet_SwordFighting.Swiftness");
FGameplayTag UAttributeSet_SwordFighting::GetGameplayTag_Swiftness() const
{
	return FGameplayTag::RequestGameplayTag(FName("AttributeSets.AttributeSet_SwordFighting.Swiftness"));
}
UE_DEFINE_GAMEPLAY_TAG(TAG_AttributeSet_SwordFighting_SwordTechnique, "AttributeSets.AttributeSet_SwordFighting.SwordTechnique");
FGameplayTag UAttributeSet_SwordFighting::GetGameplayTag_SwordTechnique() const
{
	return FGameplayTag::RequestGameplayTag(FName("AttributeSets.AttributeSet_SwordFighting.SwordTechnique"));
}

#pragma endregion

class FLifetimeProperty;

UAttributeSet_SwordFighting::UAttributeSet_SwordFighting()
	: Swiftness(0.0f), SwordTechnique(0.0f)
{
}

#pragma region Replication
void UAttributeSet_SwordFighting::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME_CONDITION_NOTIFY(UAttributeSet_SwordFighting, Swiftness, COND_OwnerOnly, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UAttributeSet_SwordFighting, SwordTechnique, COND_OwnerOnly, REPNOTIFY_Always);

}

void UAttributeSet_SwordFighting::OnRep_Swiftness(const FGameplayAttributeData& OldValue)
{
	static FProperty* Prop = FindFieldChecked<FProperty>(UAttributeSet_SwordFighting::StaticClass(), GET_MEMBER_NAME_CHECKED(UAttributeSet_SwordFighting, Swiftness));
	ULyraAbilitySystemComponent* ASC = CastChecked<ULyraAbilitySystemComponent>(GetOuter(), ECastCheckedType::NullAllowed);
	if (IsValid(ASC))
	{
		ASC->SetBaseAttributeValueFromReplication(FGameplayAttribute(Prop), Swiftness, OldValue);
	}
	else
	{
		UE_LOG(GameAttributeSet, Error, TEXT("UAttributeSet_SwordFightings::OnRep_Swiftness: No valid ASC found"));
	}
}

void UAttributeSet_SwordFighting::OnRep_SwordTechnique(const FGameplayAttributeData& OldValue)
{
	static FProperty* Prop = FindFieldChecked<FProperty>(UAttributeSet_SwordFighting::StaticClass(), GET_MEMBER_NAME_CHECKED(UAttributeSet_SwordFighting, SwordTechnique));
	ULyraAbilitySystemComponent* ASC = CastChecked<ULyraAbilitySystemComponent>(GetOuter(), ECastCheckedType::NullAllowed);
	if (IsValid(ASC))
	{
		ASC->SetBaseAttributeValueFromReplication(FGameplayAttribute(Prop), SwordTechnique, OldValue);
	}
	else
	{
		UE_LOG(GameAttributeSet, Error, TEXT("UAttributeSet_SwordFightings::OnRep_SwordTechnique: No valid ASC found"));
	}
}


#pragma endregion

#pragma region PRE-POST Gameplay Effects
void UAttributeSet_SwordFighting::PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data)
{
	Super::PostGameplayEffectExecute(Data);
	if (Data.EvaluatedData.Magnitude != 0.0f)
	{
		FGameplayTag Tag = FGameplayTag::RequestGameplayTag(FName("AttributeSets.AttributeSet_SwordFighting." + Data.EvaluatedData.Attribute.AttributeName));
		if (Tag.IsValid())
		{
			FLyraVerbMessage Message;
			Message.Verb = Tag;
			Message.Instigator = Data.EffectSpec.GetEffectContext().GetEffectCauser();
			Message.InstigatorTags = *Data.EffectSpec.CapturedSourceTags.GetAggregatedTags();
			ULyraAbilitySystemComponent* ASC = CastChecked<ULyraAbilitySystemComponent>(GetOuter(), ECastCheckedType::NullAllowed);
			if (IsValid(ASC))
			{
				Message.Target = ASC->GetOwner();
			}
			Message.TargetTags = *Data.EffectSpec.CapturedTargetTags.GetAggregatedTags();
			Message.Magnitude = Data.EvaluatedData.Magnitude;

			UGameplayMessageSubsystem& MessageSystem = UGameplayMessageSubsystem::Get(GetWorld());
			MessageSystem.BroadcastMessage(Tag, Message);
			UE_LOG(GameAttributeSet, Verbose, TEXT("PostGameplayEffectExecute: Broadcasted msg for tag '%s' with insigator '%s' and target '%s'")
				, Tag.GetTagName(), *Message.Instigator->GetName(), *Message.Target->GetName());
		}
		else
		{
			UE_LOG(GameAttributeSet, Error, TEXT("PostGameplayEffectExecute: Broadcast failed, tag '%s' is not valid"), Tag.GetTagName());
		}
	}
	else
	{
		UE_LOG(GameAttributeSet, VeryVerbose, TEXT("PostAttributeChange: No message was broadcasted, magnitude = 0"));
	}
}
#pragma endregion

#pragma region PRE-POST Attribute Changes

void UAttributeSet_SwordFighting::PreAttributeBaseChange(const FGameplayAttribute& Attribute, float& NewValue) const
{
	Super::PreAttributeBaseChange(Attribute, NewValue);
	ClampAttribute(Attribute, NewValue);
}

void UAttributeSet_SwordFighting::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)
{
	Super::PreAttributeChange(Attribute, NewValue);
	ClampAttribute(Attribute, NewValue);
}

void UAttributeSet_SwordFighting::PostAttributeChange(const FGameplayAttribute& Attribute, float OldValue, float NewValue)
{
	Super::PostAttributeChange(Attribute, OldValue, NewValue);
	ULyraAbilitySystemComponent* ASC = CastChecked<ULyraAbilitySystemComponent>(GetOuter(), ECastCheckedType::NullAllowed);
	if (IsValid(ASC))
	{
		if (Attribute.GetGameplayAttributeData(this)->GetCurrentValue() > Attribute.GetGameplayAttributeData(this)->GetBaseValue())
		{
			ASC->ApplyModToAttribute(Attribute, EGameplayModOp::Override, NewValue);
		}
		// cast a message with PlayerState and Tag Channel for everyone listening
		if (IsValid(ASC->GetOwner()))
		{
			FGameplayTag Tag = FGameplayTag::RequestGameplayTag(FName("AttributeSets.AttributeSet_SwordFighting." + Attribute.AttributeName));
			if (Tag.IsValid())
			{
				FLyraNotificationMessage Message;
				Message.TargetChannel = Tag;
				Message.TargetPlayer = (APlayerState*)ASC->GetOwner();
				UGameplayMessageSubsystem& MessageSystem = UGameplayMessageSubsystem::Get(GetWorld());
				MessageSystem.BroadcastMessage(Tag, Message);
				UE_LOG(GameAttributeSet, Verbose, TEXT("PostAttributeChange: Broadcasted msg for tag '%s' - oldvalue: %d, new value: %d")
					, Tag.GetTagName(), OldValue, NewValue);
			}
			else
			{
				UE_LOG(GameAttributeSet, Error, TEXT("PostAttributeChange: Broadcast failed, tag '%s' is not valid"), Tag.GetTagName());
			}
		}
		else
		{
			UE_LOG(GameAttributeSet, Error, TEXT("PostAttributeChange: Getting a valid owner from ASC failed - aborted"));
		}
	}
	else
	{
		UE_LOG(GameAttributeSet, Error, TEXT("PostAttributeChange: Getting a valid ASC failed - aborted"));
	}
}

void UAttributeSet_SwordFighting::OnAttributeAggregatorCreated(const FGameplayAttribute& Attribute, FAggregator* NewAggregator) const
{
	Super::OnAttributeAggregatorCreated(Attribute, NewAggregator);

	if (!NewAggregator)
	{
		return;
	}
	/*
	// Example from Tranek: Only leave the most negative mod but all positive mods on each attribute (example: movement speed)
	if (Attribute == GetMoveSpeedAttribute())
	{
		NewAggregator->EvaluationMetaData = &FAggregatorEvaluateMetaDataLibrary::MostNegativeMod_AllPositiveMods;
	}
	*/
}

void UAttributeSet_SwordFighting::ClampAttribute(const FGameplayAttribute& Attribute, float& NewValue) const
{
	// Do not allow the new value to be higher than base value
	auto Data = Attribute.GetGameplayAttributeData(this);
	if (Data->GetBaseValue() < Data->GetCurrentValue())
	{
		NewValue = Data->GetBaseValue();
		UE_LOG(GameAttributeSet, Warning, TEXT("Current value for %s is %d, but base value is smaller at %d. New value clamped at to base value")
			, *Attribute.AttributeName, Data->GetCurrentValue(), Data->GetBaseValue());
	}
}
#pragma endregion